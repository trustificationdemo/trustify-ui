import React from "react";

import type { VulnerabilityStatus } from "@app/api/models";
import type {
  PurlSummary,
  VulnerabilityAdvisorySummary,
  VulnerabilitySbomStatus,
} from "@app/client";
import { useFetchVulnerabilityById } from "@app/queries/vulnerabilities";

const areSbomOfVulnerabilityEqual = (
  a: SbomOfVulnerability,
  b: SbomOfVulnerability | FlatSbomOfVulnerability,
) => {
  return a.sbom.id === b.sbom.id && a.sbomStatus === b.sbomStatus;
};

interface FlatSbomOfVulnerability {
  sbom: VulnerabilitySbomStatus;
  sbomStatus: VulnerabilityStatus;
  advisory: VulnerabilityAdvisorySummary;
  packages: PurlSummary[];
}

export interface SbomOfVulnerability {
  sbom: VulnerabilitySbomStatus;
  sbomStatus: VulnerabilityStatus;
  relatedPackages: {
    advisory: VulnerabilityAdvisorySummary;
    packages: PurlSummary[];
  }[];
}

export interface SbomOfVulnerabilitySummary {
  total: number;
  sbomStatus: { [key in VulnerabilityStatus]: number };
}

const DEFAULT_SUMMARY: SbomOfVulnerabilitySummary = {
  total: 0,
  sbomStatus: { affected: 0, fixed: 0, known_not_affected: 0, not_affected: 0 },
};

const advisoryToModels = (advisories: VulnerabilityAdvisorySummary[]) => {
  const sboms = advisories
    .flatMap((advisory) => {
      return (advisory.sboms ?? []).flatMap((sbomStatuses) => {
        return Object.entries(sbomStatuses.purl_statuses || {}).map(
          ([status, packages]) => {
            const result: FlatSbomOfVulnerability = {
              sbom: {
                ...sbomStatuses,
              },
              sbomStatus: status as VulnerabilityStatus,
              advisory: advisory,
              packages: packages,
            };
            return result;
          },
        );
      });
    })
    // group
    .reduce((prev, current) => {
      const existingElement = prev.find((item) => {
        return areSbomOfVulnerabilityEqual(item, current);
      });

      let result: SbomOfVulnerability[];

      if (existingElement) {
        const arrayWithoutExistingItem = prev.filter(
          (item) => !areSbomOfVulnerabilityEqual(item, existingElement),
        );

        const updatedItemInArray: SbomOfVulnerability = {
          ...existingElement,
          relatedPackages: [
            ...existingElement.relatedPackages,
            {
              advisory: current.advisory,
              packages: current.packages,
            },
          ],
        };

        result = [...arrayWithoutExistingItem, updatedItemInArray];
      } else {
        const newItemInArray: SbomOfVulnerability = {
          sbom: current.sbom,
          sbomStatus: current.sbomStatus,
          relatedPackages: [
            {
              advisory: current.advisory,
              packages: current.packages,
            },
          ],
        };
        result = [...prev.slice(), newItemInArray];
      }

      return result;
    }, [] as SbomOfVulnerability[]);

  const summary = sboms.reduce(
    (prev, current) => {
      const sbomStatus = current.sbomStatus;
      return Object.assign(prev, {
        total: prev.total + 1,
        sbomStatus: {
          ...prev.sbomStatus,
          [sbomStatus]: prev.sbomStatus[sbomStatus] + 1,
        },
      });
    },
    { ...DEFAULT_SUMMARY } as SbomOfVulnerabilitySummary,
  );

  return {
    sboms,
    summary,
  };
};

export const useSbomsOfVulnerability = (sbomId: string) => {
  const {
    vulnerability,
    isFetching: isFetchingAdvisories,
    fetchError: fetchErrorAdvisories,
  } = useFetchVulnerabilityById(sbomId);

  const result = React.useMemo(() => {
    return advisoryToModels(vulnerability?.advisories || []);
  }, [vulnerability]);

  return {
    data: result,
    isFetching: isFetchingAdvisories,
    fetchError: fetchErrorAdvisories,
  };
};
